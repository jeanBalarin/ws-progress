
/*------------------------------------------------------------------------
    File        : customerService.p
    Purpose     : camada de acesso ao banco CRUD

    Syntax      :

    Description : serviços associados a clientes operações e consultas no banco    

    Author(s)   : jeanBalarin
    Created     : Tue Sep 26 20:22:19 BRT 2023
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */

BLOCK-LEVEL ON ERROR UNDO, THROW.

{customer/dscustomer.i}

/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */

PROCEDURE findAllCustomer:
    DEFINE OUTPUT PARAMETER DATASET FOR dsCustomer. // temporary table for data output 
    DEFINE OUTPUT PARAMETER iCodeStatus AS INTEGER  NO-UNDO.
    //MESSAGE 'chamou as : ' + string(today, "99/99/99") +  " "  + string(time, "hh:mm:ss").
   
    FOR EACH Customer NO-LOCK:  
        CREATE ttCustomer.
        BUFFER-COPY Customer TO ttCustomer.
    END.
     
    iCodeStatus = 200. 
    RETURN. 
    
END PROCEDURE.

PROCEDURE findByIdCustomer:
    DEFINE INPUT PARAMETER ipCodigo AS INTEGER NO-UNDO.
    DEFINE OUTPUT PARAMETER DATASET FOR dsCustomer.
    DEFINE OUTPUT PARAMETER iCodeStatus AS INTEGER NO-UNDO.
    
    IF ipCodigo >= 0 THEN DO:
        FIND FIRST Customer NO-LOCK WHERE 
            Customer.CustNum = ipCodigo NO-ERROR.    
        
        IF AVAILABLE Customer THEN DO:
            BUFFER-COPY Customer TO ttCustomer.
            iCodeStatus = 200.
        END.
        ELSE DO:
            CREATE ttErro.
            ASSIGN 
                ttErro.msg     = 'Cliente não encontrado para codigo informado!'
                ttErro.success = FALSE
                iCodeStatus    = 404. // not found
        END.    
    END.
    ELSE DO:
        CREATE ttErro.
        ASSIGN 
            ttErro.msg     = 'Codigo informado é inválido!'
            ttErro.success = FALSE
            iCodeStatus    = 400. // bad request
    END.
END PROCEDURE.

DEFINE TEMP-TABLE ttNewCustomer-ref_only NO-UNDO REFERENCE-ONLY LIKE ttNewCustomer.

PROCEDURE pCreateCustomer:
    DEFINE INPUT PARAMETER TABLE FOR ttNewCustomer-ref_only .
    DEFINE OUTPUT PARAMETER DATASET FOR dsCustomer.
    DEFINE OUTPUT PARAMETER iCodeStatus AS INTEGER NO-UNDO.
    
    DO ON ERROR UNDO, LEAVE:
        IF CAN-FIND (FIRST ttNewCustomer-ref_only) THEN DO:
            FOR FIRST ttNewCustomer-ref_only:
                MESSAGE "RECID SERVICE REF only: "RECID(ttNewCustomer-ref_only).
                CREATE Customer.
                BUFFER-COPY ttNewCustomer-ref_only TO Customer.
                Customer.CustNum = NEXT-VALUE (NextCustNum).
                  
                CREATE ttResultsCust.
                ASSIGN 
                    ttResultsCust.CustNum = Customer.CustNum
                    ttResultsCust.Name    = Customer.Name
                    ttResultsCust.SalesRep = Customer.SalesRep
                    ttResultsCust.success  = TRUE 
                    tttResultsCust.msg      = "Cliente criado com sucesso!"
                    iCodeStatus = 201.
            END.
        END.
        ELSE DO:
            CREATE ttErro.
            ASSIGN 
                ttErro.success = FALSE
                ttErro.msg     = 'Requisição imcompleta!'
                iCodeStatus    = 400.
        END.
        CATCH sysError AS Progress.Lang.SysError :
            CREATE ttErro.
            ASSIGN
                ttErro.success = FALSE 
                ttErro.msg     = sysError:GetMessage(1)
                iCodeStatus    = 500.      
        END CATCH. 
    END.
END.

PROCEDURE pUpdateCustomer:
    DEFINE INPUT PARAMETER ipCode AS INTEGER NO-UNDO.
    DEFINE INPUT PARAMETER TABLE FOR ttNewCustomer.
    DEFINE OUTPUT PARAMETER DATASET FOR dsCustomer.
    DEFINE OUTPUT PARAMETER icodeStatus AS INTEGER NO-UNDO.
    
    DO ON ERROR UNDO, LEAVE:
        FIND FIRST Customer EXCLUSIVE-LOCK WHERE
            Customer.CustNum = ipCode NO-ERROR.
        IF AVAILABLE Customer THEN DO:
            FOR FIRST ttNewCustomer NO-LOCK:
                BUFFER-COPY ttNewCustomer TO Customer.
            END.
            
            CREATE ttResults.
            BUFFER-COPY Customer TO ttResults.
            ASSIGN 
                ttResults.success = TRUE
                ttResults.msg     =  "Cliente Alterado com sucesso!"
                icodeStatus = 200.           
        END.
        ELSE DO:
            CREATE ttErro.
            ASSIGN
            ttErro.msg       = "Cliente não localizado"
            ttErro.success   = FALSE
            icodeStatus      = 400.
         END.
         CATCH sysErro AS Progress.Lang.Error :
             CREATE ttErro.
             ASSIGN
                 ttErro.msg     = sysErro:GetMessage(1)
                 ttErro.success = FALSE
                 icodeStatus    = 500.
         END CATCH.       
    END.
END PROCEDURE.

PROCEDURE pDeleteCustomer:
    DEFINE INPUT PARAMETER ipCode AS INTEGER NO-UNDO.
    DEFINE OUTPUT PARAMETER DATASET FOR dsCustomer.
    DEFINE OUTPUT PARAMETER icodeStatus AS INTEGER NO-UNDO.
    
    DO ON ERROR UNDO, LEAVE:
        FIND FIRST Customer EXCLUSIVE-LOCK WHERE
            Customer.CustNum = ipCode NO-ERROR.
        IF AVAILABLE Customer THEN DO:
            MESSAGE 'AVL CUSTOMER'
            VIEW-AS ALERT-BOX.
            CREATE ttResults.
            BUFFER-COPY Customer TO ttResults.
            ASSIGN 
                ttResults.success = TRUE
                ttResults.msg     = "Cliente Deletado com sucesso!"
                icodeStatus       = 200. 
                
            DELETE Customer.  
            RELEASE Customer. 
            RELEASE ttResults.           
        END.
        ELSE DO:
            CREATE ttErro.
            ASSIGN
                ttErro.msg     = "Cliente não localizado"
                ttErro.success = FALSE
                icodeStatus    = 400.
                RELEASE ttErro.
        END.
        CATCH sysErro AS Progress.Lang.Error :
            EMPTY TEMP-TABLE ttResults.
            CREATE ttErro.
            ASSIGN
                ttErro.msg     = sysErro:GetMessage(1)
                ttErro.success = FALSE
                icodeStatus    = 500.
        END CATCH. 
        FINALLY:
            FOR FIRST ttResults:
                MESSAGE "RECID SERVICE: " RECID(ttResults).
            END.         
        END FINALLY.   
    END.
END PROCEDURE.

// procedure retorna a consulta de clientes paginada para os testes de aprendizagem inicial da rotina.
PROCEDURE findCustomerPage:
    DEFINE INPUT PARAMETER inpPageSize AS INTEGER NO-UNDO.
    DEFINE INPUT PARAMETER inpCodPage  AS INTEGER NO-UNDO.
    DEFINE OUTPUT PARAMETER DATASET    FOR dsCustomer.
    DEFINE OUTPUT PARAMETER iCodeStatus AS INTEGER NO-UNDO.
    
    DEFINE VARIABLE cWhere AS CHARACTER NO-UNDO.
    
    BUFFER  ttErro:FILL-MODE    = "NO-FILL".
    BUFFER  ttResults:FILL-MODE = 'NO-FILL'.
    BUFFER  ttPage:FILL-MODE    = "NO-FILL".
    
    // definição da query que vai fazer a consulta no banco
    DEFINE DATA-SOURCE srcCustomer FOR Customer.
    // attach do buffer da tt no data-source para carregar as informações.
    BUFFER ttCustomer:ATTACH-DATA-SOURCE (DATA-SOURCE srcCustomer:HANDLE).
    
    

    // valor padrão para o bath-size da tt pai é 0 e indica que carregará todos os registros.
    IF inpPageSize > 0 AND inpPageSize <> ? THEN DO:
        BUFFER ttCustomer:BATCH-SIZE = inpPageSize.  
    END.
    IF inpCodPage <> 0 AND inpCodPage <> ? THEN DO:
        
        FIND FIRST Customer NO-LOCK WHERE 
            RECID(Customer) = inpCodPage.
        IF AVAILABLE Customer THEN DO:
            DATA-SOURCE srcCustomer:RESTART-ROWID = ROWID(Customer).    
        END.
        ELSE DO:
            RETURN 'nok':U.
        END.
    END.
    DATASET dsCustomer:FILL (). 
    
    BUFFER  ttErro:FILL-MODE    = "MERGE".
    BUFFER  ttResults:FILL-MODE = 'MERGE'.
    BUFFER  ttPage:FILL-MODE    = "MERGE".
    
     
    
    CREATE ttPage.
    IF CAN-FIND(FIRST ttCustomer ) THEN DO:
        
        IF DATA-SOURCE srcCustomer:NEXT-ROWID <> ? THEN DO:
            FIND FIRST Customer NO-LOCK WHERE 
                ROWID(Customer) = DATA-SOURCE srcCustomer:NEXT-ROWID  NO-ERROR.
                
            IF AVAILABLE Customer THEN DO:
                ASSIGN 
                    ttPage.nextPage = RECID(Customer) 
                    ttPage.sizePage = inpPageSize.
            END.       
        END.
    END.
    ELSE DO:  
        MESSAGE('não achou os dados').
        ASSIGN  
            ttPage.nextPage = ?
            ttPage.sizePage = inpPageSize.
    END.
    iCodeStatus = 200.
    RETURN "OK":U.
    FINALLY:
        // trata o detach da fonte de dados. 
        BUFFER ttCustomer:DETACH-DATA-SOURCE ().    
    END FINALLY.
END PROCEDURE.


